(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{338:function(e,t,a){"use strict";a.r(t);var v=a(14),r=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"【稿】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【稿】"}},[e._v("#")]),e._v(" 【稿】")]),e._v(" "),t("h2",{attrs:{id:"响应式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应式"}},[e._v("#")]),e._v(" 响应式")]),e._v(" "),t("p",[e._v("vue在初始化阶段会使用Object.defineProperty(Vue3为proxy)实现属性的响应式。其中get被触发时会进行依赖收集(get被触发，渲染时，对应数据属性的Dep里面，每个组件有个watcher对象)，等到数据更改触发set的时候会通知属性对应的依赖（watch）进行视图更新")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("1、初始化时深度遍历计算开销大（vue get触发时），proxy针对对象进行监听，而不是对象属性的。Proxy访问到某个属性时再代理（get触发）")]),e._v(" "),t("li",[e._v("2、无法检测到对象新增/删除属性（因此需要 Vue.set 与 Vue.delete方法）")]),e._v(" "),t("li",[e._v("3、无法直接监听数组变化（长度变化和通过索引设置数组项），需要调用数组方法")]),e._v(" "),t("li",[e._v("4、还可以监听 Map、Set、WeakSet、WeakMap 等数据结构\n在 Vue3.0中采用了 ES6 的 Proxy 来代替 Object.defineProperty，解决了以上缺陷并提高了性能。")])])]),e._v(" "),t("h2",{attrs:{id:"vnode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vnode"}},[e._v("#")]),e._v(" vnode")]),e._v(" "),t("p",[e._v("vnode就是用js对象属性来描述dom节点，是对真实dom的抽象，Virtual Dom就是vnode节点为基础的树\n使用虚拟dom原因一个是直接修改真实dom开销大，虚拟dom可以先让js在内存中进行大量操作，只将最后的结果保留进行dom操作，而不是频繁修改真实dom。能提高性能和渲染效率，开发者可以更专注于业务逻辑而不是dom操作，另外因为它以js对象为基础不依赖平台环境而，更容易进行跨平台开发\n不过最近也有框架 Svelte 实现无虚拟dom")]),e._v(" "),t("h2",{attrs:{id:"template渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#template渲染"}},[e._v("#")]),e._v(" template渲染")]),e._v(" "),t("p",[e._v("首先解析 用正则等方式解析模版形成ast\n优化ast结构、标记静态节点\nast生成渲染函数，生成虚拟dom\n首次渲染没有旧的虚拟dom，直接创建DOM插入到页面上")]),e._v(" "),t("h2",{attrs:{id:"diff"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff"}},[e._v("#")]),e._v(" Diff")]),e._v(" "),t("p",[e._v("用来对比得出两个 VNode 对象之间的差异。(传统两棵树做diff复杂度O(3))")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("1、只比较同一层级 不跨级比较。降低了复杂度")]),e._v(" "),t("li",[e._v("2、tag、key、isComment、data是否定义 都相同则认为是相同节点,tag不同直接删掉重建， 不深度比较")])])]),e._v(" "),t("p",[e._v("两者都有子节点,而且子节点不一样会触发updateChildren,vNode和oldVnode的children索引从两端到中间移动开始进行比较。\n如果没有匹配到会进行oldChildren遍历与start比较。如果仍没有成功的会插入start到dom中对应oldStart位置")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("vue2 双端比较")]),e._v(" "),t("li",[e._v("vue3 最长递增子序列（减少了移动）增加了静态标记，不会比较标记了静态节点的标签")]),e._v(" "),t("li",[e._v("react仅右移")])])]),e._v(" "),t("h2",{attrs:{id:"vue3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3"}},[e._v("#")]),e._v(" VUE3")]),e._v(" "),t("p",[e._v("composition Api 更好的代码组织和逻辑复用，不会想mixins一样产生一些冲突的问题\n全局 API 进行分块，支持treeshaking\n响应式采用了proxy\ndiff算法优化\nhoist static提升静态常量，元素静态节点提升到顶级作用域，cacheHandle 缓存事件；不用每次render重复执行\npatchFlag 编译模板时动态节点做标记，区分不同类型，diff时可以区分静态节点和不同的动态节点\n性能 体积")]),e._v(" "),t("p",[e._v("fragment template内 不用一个容器\nsuspense 异步组件\ntoRef、toRefs 将响应式对象的属性转为ref对象。对象新增属性或解构赋值不能初始化需要用到\n1、setup")]),e._v(" "),t("h2",{attrs:{id:"优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[e._v("#")]),e._v(" 优化")]),e._v(" "),t("p",[e._v("FP\nFCP（First Contentful Paint）：首次内容绘制时间\nLCP（Largest Contentful Paint）：最大内容绘制时间，用于记录视窗内最大的元素绘制的时间\nTTI 可交互时间\nFID 首次输入延迟\nINP 从交互到下一次绘制的延时\nCLS（Cumulative Layout Shift）：累计位移偏移")]),e._v(" "),t("p",[e._v("用（babel-loader） include 或 exclude 来帮我们避免不必要的转译。node_modules\nDllPlugin 处理第三方库（node_modules），这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包\nHappypack——将 loader 由单进程转为多进程；treeshaking删除冗余代码\ngzip")]),e._v(" "),t("p",[e._v("对图片进行优化，小图片使用base64，雪碧图等方式。使用压缩性能更好的webp等（服务端accept字段进行判断、加载webp尝试获取宽高）。\n提前设置图片宽高、动态元素预留控件，减少回流重绘，体现在指标上也就是cls\nlottie 动画设置静态 背景图，监听到加载完成的事件后再换成动画\nspider-font\nvue组件异步加载、路由懒加载")]),e._v(" "),t("p",[e._v('重要图片预加载，link标签的rel="preload"或者js Image对象\n延迟、按需加载\n优化长任务（WebWorker、requestIdlecallback、防抖节流）\nlighthouse建议\n性能监控\n————————————————————————\n使用 CDN\n图片懒加载\n组件、路由的异步加载\n本地存储 localstorage\n图片方面：小图片使用base64，雪碧图等方式；使用压缩性能更好的webp格式同时做好降级方案；spider-font进行字体压缩 提前设置图片宽高、减少回流重绘\nwebpack构建方面：exclude限定loader范围；DllPlugin把第三方库单独打包，只有依赖自身变化的时候重新打包；使用happypack或者thread-loader开启多进程并发打包；\nspeed-measure-webpack-plugin 发现babel-loader sass-loader耗时长，使用了thread-loader（放到线程池里实现多线程）和开启缓存cacheDirectory')]),e._v(" "),t("p",[e._v("使用本地存储、懒加载、异步加载、减少回流重绘（集中dom操作、）")]),e._v(" "),t("h2",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[e._v("#")]),e._v(" webpack")]),e._v(" "),t("p",[e._v("模块打包、开发服务器、资源优化")]),e._v(" "),t("p",[e._v("vite 开发环境利用浏览器对esmodule的支持，可以直接进行模块的按需加载，而不是先整体打包再进行加载；按需加载，不用编译全部相关依赖；利用了esbuild(go编写)\n生产环境rollup；开箱即用、配置简单(内置了hmr、babel、PostCSS、vue、react支持等)；vite首屏和加载慢\n生产环境rollup，使用ESM、体积小（polyfill）；\n研发rolldown作为rollup的替代品，esmodule快不够成熟灵活（代码分割）、rollup成熟灵活但不够快（比起本地）")]),e._v(" "),t("p",[e._v("Rollup基于ESM的，默认支持treeshaking 一般用于打包类库而不是程序，\nwebpack大而全、生态和兼容性好,可以打包任何资源")]),e._v(" "),t("p",[e._v("webpack5：性能提升 更快构建更小体积、持久化缓存（存在磁盘而非内存中，不仅在一次构建中有效）、模块联邦、")]),e._v(" "),t("blockquote",[t("ol",[t("li",[e._v("从配置文件和命令行中读取合并参数")]),e._v(" "),t("li",[e._v("初始化compiler对象，加载插件，开始编译")]),e._v(" "),t("li",[e._v("从配置中的entry入口文件出发，根据依赖递归地调用loader对模块进行编译")]),e._v(" "),t("li",[e._v("根据入口和模块的依赖关系组装成chunk、再把chunk转化为bundle加入到输出列表")]),e._v(" "),t("li",[e._v("根据配置确定路径和文件名，将文件写入系统中。")]),e._v(" "),t("li",[e._v("以上过程中webpack会在特定时间点广播出事件，插件监听后运行特定的逻辑")])])]),e._v(" "),t("p",[e._v("常用loader: style-loader、babel-loader、css-loader、less-loader、vue-loader\n常用plugin: HtmlWebpackPlugin、MiniCssExtractPlugin、DllPlugin、Happypack  webpack-bundle-analyzer\nspeed measure")]),e._v(" "),t("p",[e._v("treeshaking 依赖于esmodule语法在编译时加载，可以通过静态分析确定模块的依赖关系，标记出未使用的代码并将其剔除")]),e._v(" "),t("h2",{attrs:{id:"从输入url"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从输入url"}},[e._v("#")]),e._v(" 从输入url")]),e._v(" "),t("ol",[t("li",[e._v("构建请求")]),e._v(" "),t("li",[e._v("查找强缓存")]),e._v(" "),t("li",[e._v("dns查询,获取ip")]),e._v(" "),t("li",[e._v("建立 TCP 连接")]),e._v(" "),t("li",[e._v("发送 HTTP 请求")]),e._v(" "),t("li",[e._v("解析HTML，构建 DOM 树")]),e._v(" "),t("li",[e._v("解析 CSS ，生成 CSSOM 树")]),e._v(" "),t("li",[e._v("合并 DOM 树和 CSS 规则，生成 render 树")]),e._v(" "),t("li",[e._v("布局 render 树，负责各元素尺寸、位置的计算")]),e._v(" "),t("li",[e._v("绘制 render 树，绘制页面像素信息")]),e._v(" "),t("li",[e._v("将绘制的结果合成到屏幕上，以完成渲染。")])]),e._v(" "),t("p",[e._v("CSS 不会阻塞 DOM 解析（link 在 head 中）\nCSS 会阻塞 DOM 树的渲染（阻塞 render tree 的形成）")]),e._v(" "),t("h2",{attrs:{id:"esmodule、commonjs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esmodule、commonjs"}},[e._v("#")]),e._v(" ESmodule、commonjs")]),e._v(" "),t("p",[e._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\nCommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\nCommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立模块依赖的解析阶段。")]),e._v(" "),t("h2",{attrs:{id:"缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[e._v("#")]),e._v(" 缓存")]),e._v(" "),t("img",{attrs:{src:e.$withBase("/浏览器/缓存.webp")}}),e._v(" "),t("h2",{attrs:{id:"跨域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[e._v("#")]),e._v(" 跨域")]),e._v(" "),t("p",[e._v("两个url的host、port、protocal相同被视为同源，跨域发送的ajax请求会遭到拦截。JSONP、CORS、反向代理")]),e._v(" "),t("p",[e._v("服务端设置 Access-Control-Allow-Origin 响应头就可以开启CORS，表示对应的origin可以访问资源\n非简单请求发送options预检查请求")]),e._v(" "),t("p",[e._v("【】非简单请求【】")]),e._v(" "),t("h2",{attrs:{id:"观察者模式、发布订阅模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式、发布订阅模式"}},[e._v("#")]),e._v(" 观察者模式、发布订阅模式")]),e._v(" "),t("p",[e._v("观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新")]),e._v(" "),t("p",[e._v("发布者和订阅者之间不直接进行订阅事件和通知操作，而是通过一个事件中心进行间接的通信")]),e._v(" "),t("h2",{attrs:{id:"网络安全xss、csrf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络安全xss、csrf"}},[e._v("#")]),e._v(" 网络安全xss、csrf")]),e._v(" "),t("p",[e._v("xss全名为跨站脚本攻击，攻击者在受害者的浏览器中执行恶意脚本，以获取受害者cookie或者监听行为之类的操作。比如通过评论区之类将输入恶意脚本保存到数据库、或者利用页面上依赖参数请求的动态元素让受害者点击链接。主要防范方式是前后端都对用户输入进行转义、过滤，设置Cookie为httponly,禁止js读取")]),e._v(" "),t("p",[e._v("csrf即为跨站请求伪造，攻击者通过用户的登陆凭证，冒充用户发起请求。防范方式有csrf token、设置cookie的samesite属性为strict、敏感操作增加双重验证等")]),e._v(" "),t("h2",{attrs:{id:"node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[e._v("#")]),e._v(" node")]),e._v(" "),t("h3",{attrs:{id:"如何优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何优化"}},[e._v("#")]),e._v(" 如何优化")]),e._v(" "),t("p",[e._v("使用redis缓存一些频繁访问的数据、监控\n数据库批量操作\n优化数据库设计、索引和查询\n计算密集型的场景，创建线程")]),e._v(" "),t("h3",{attrs:{id:"和koa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#和koa"}},[e._v("#")]),e._v(" 和koa")]),e._v(" "),t("p",[e._v("常用中间件 body-parser\nexpress更成熟、社区和方案更庞大、callback风格\nkoa 中间件更灵活、async、await、更轻量级、按需引入")]),e._v(" "),t("h2",{attrs:{id:"jwt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[e._v("#")]),e._v(" jwt")]),e._v(" "),t("p",[e._v("session是将用户信息存储在服务端，硬件成本高，多服务器时需要通过缓存等方式同步，有跨域限制\n而且jwt是客户端自行存储，token体积一般较大，请求数据量也会增大,如果泄漏密钥，用户信息会流失。\n有严格管理用户信息的需求（保密、封禁）用session")]),e._v(" "),t("h2",{attrs:{id:"小程序实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小程序实现原理"}},[e._v("#")]),e._v(" 小程序实现原理")]),e._v(" "),t("p",[e._v("基于双线程的，小程序的渲染层和逻辑层在不同线程\n首屏\n逻辑层js运行在沙盒环境中，限制了访问权限\nwxml转化为js对象也就是虚拟DOM,\n安全（阻止了直接操作dom、跳转页面等）、多线程不会guih和js引擎、阻塞，传递数据用setData")]),e._v(" "),t("h2",{attrs:{id:"小程序生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小程序生命周期"}},[e._v("#")]),e._v(" 小程序生命周期")]),e._v(" "),t("h3",{attrs:{id:"应用生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用生命周期"}},[e._v("#")]),e._v(" 应用生命周期")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("onLaunch\t小程序初始化完成时触发，全局只触发一次")]),e._v(" "),t("li",[e._v("onShow\t小程序启动，或从后台进入前台显示时触发")]),e._v(" "),t("li",[e._v("onHide\t小程序从前台进入后台时触发")]),e._v(" "),t("li",[e._v("onError\t小程序发生脚本错误或 API 调用报错时触发")]),e._v(" "),t("li",[e._v("onPageNotFound\t小程序要打开的页面不存在时触发")]),e._v(" "),t("li",[e._v("onUnhandledRejection()\t小程序有未处理的 Promise 拒绝时触发")]),e._v(" "),t("li",[e._v("onThemeChange\t系统切换主题时触发")])])]),e._v(" "),t("h3",{attrs:{id:"页面生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页面生命周期"}},[e._v("#")]),e._v(" 页面生命周期")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("onLoad\t生命周期回调—监听页面加载\t发送请求获取数据")]),e._v(" "),t("li",[e._v("onShow\t生命周期回调—监听页面显示\t请求数据")]),e._v(" "),t("li",[e._v("onReady\t生命周期回调—监听页面初次渲染完成\t获取页面元素（少用）")]),e._v(" "),t("li",[e._v("onHide\t生命周期回调—监听页面隐藏\t终止任务，如定时器或者播放音乐")]),e._v(" "),t("li",[e._v("onUnload\t生命周期回调—监听页面卸载\t终止任务")])])]),e._v(" "),t("h3",{attrs:{id:"组件生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件生命周期"}},[e._v("#")]),e._v(" 组件生命周期")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("created\t生命周期回调—监听页面加载")]),e._v(" "),t("li",[e._v("attached\t生命周期回调—监听页面显示")]),e._v(" "),t("li",[e._v("ready\t生命周期回调—监听页面初次渲染完成")]),e._v(" "),t("li",[e._v("moved\t生命周期回调—监听页面隐藏")]),e._v(" "),t("li",[e._v("detached\t生命周期回调—监听页面卸载")]),e._v(" "),t("li",[e._v("error\t每当组件方法抛出错误时执行")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);