(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{309:function(t,a,r){"use strict";r.r(a);var s=r(14),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"垃圾回收和内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收和内存泄漏"}},[t._v("#")]),t._v(" 垃圾回收和内存泄漏")]),t._v(" "),a("h2",{attrs:{id:"标记清除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[t._v("#")]),t._v(" 标记清除")]),t._v(" "),a("p",[t._v("标记阶段：从根对象（如全局对象、局部变量等）开始，通过可达性分析，标记所有可以被访问到的对象。\n清除阶段：在标记阶段完成后，垃圾回收器会遍历整个内存空间，清除未被标记的对象。这些未被标记的对象被认为是不可达的，因此可以安全地释放它们所占用的内存。")]),t._v(" "),a("h2",{attrs:{id:"引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),a("p",[t._v('引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放\n如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏')]),t._v(" "),a("h2",{attrs:{id:"内存泄漏原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏原因"}},[t._v("#")]),t._v(" 内存泄漏原因")]),t._v(" "),a("p",[t._v("意外的全局变量、未及时清除的定时器、对dom的引用、事件监听")]),t._v(" "),a("h2",{attrs:{id:"检测内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检测内存泄漏"}},[t._v("#")]),t._v(" 检测内存泄漏")]),t._v(" "),a("p",[t._v("chrome开发工具 performance 观察heap的变化规律。内存快照找出导致泄漏的函数或变量，出现时间")]),t._v(" "),a("h2",{attrs:{id:"flex1和-auto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flex1和-auto"}},[t._v("#")]),t._v(" flex1和 auto")]),t._v(" "),a("p",[t._v("flex：1 适用等分布局\nflex：auto 适用基于内容动态适配的布局")]),t._v(" "),a("h2",{attrs:{id:"worker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker"}},[t._v("#")]),t._v(" worker")])])}),[],!1,null,null,null);a.default=e.exports}}]);